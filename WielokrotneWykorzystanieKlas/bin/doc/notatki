Ogolnie:

	W javie powtórne uzycie kodu jest mo¿liwe dziêki tworzeniu nowych klas, ale zamiast tworzyæ je od podstaw wykorzystuje siê te ju¿ istniej¹ce (które
np. zbudowa³ ktoœ inny). Polega to wszystko na korzystaniu z istniej¹cych klas, ale bez modyfikacji ich kodu. 
	Istniej¹ 2 sposoby na osi¹gniêcie tego: tworzenie nowych obiektów klas ju¿ istniej¹cych jako sk³adowe innych klas. Czyli standardowe
tworzenie obiektu jakiejœ klasy z funkcjami. Takie coœ nazywa siê kompozycj¹, bo nowa klasa skomponowana jest z obiektów ju¿ istniej¹cych klas. My tylko
wykorzystujemy ponownie funkcje kodu, a nie jego postaæ.
	Drugie rozwi¹zanie polega na stworzeniu nowej klasy jako typu klasy istniej¹cej. Do klasy istniaj¹cej dodajemy nowy kod, bez modyfikacji istniej¹cego,
a ca³¹ resztê robi kompilator. Takie coœ nazywamy dziedziczeniem. Sk³adnia i zachowanie w obi tych rozwi¹zaniach s¹ podobne.

1. Sk³adnia kompozycji
Widaæ tutaj metodê toString(). 
Tak jak ju¿ wiadomo, bo mówi³em o tm wczeœniej, typy podstawowe s¹ automatycznie inicjalizowane zerem, a referencje do obiektów ustawiane s¹ na null, co
przy próbie wywo³ania metody na recz któregoœ z takich obiektów spowoduje zg³oszenie wyj¹tku (b³êdu czasu wykonania). Puste referencje natomiast mo¿na
wypisaæ nie powoduj¹c zg³oszenia wyj¹tku, co jest wygodne ale te¿ dziwne.

To, ¿e kompilator nie tworzy po porstu domyœlnego obiektu dla ka¿dej referencji ma uzsadanienie, poniewa¿ nara¿a³oby to w wielu przypadkach na
niepotrzebne koszty. Je¿eli chcemy, by odwólania by³y zainicjowane, mo¿na to zrobic:
- w miejsuc definiowania obiektów, co oznacza, ¿e zawsze bêd¹ inicjowane przed wywo³aniem konstruktora.
- wewn¹trz konstruktora danej klasy.
- tu¿ przed zajœciem potrzeby u¿ycia obiektu, co czêsto nazywane jest !inicjalizacj¹ leniw¹!. Mo¿e to zmniejszyæ koszty w przypadkach,
gdy tworzenie obiektu jest czasoch³onne, a obiekty nie wymagaj¹ tworzenia ka¿dorazowo.
- za pomoc¹ mechanizmu nicjalizacji egzemplarzy niestatycznych. 
	Wszystkie te cztery spospby przedstawiono w SkladniKompozycji w klasach Soap i Bath.
Warto zauwa¿yæ, ¿e instrukcja wypisuj¹ca wewn¹trz konstruktora klasy Bath jest wykonywana jeszcze zanim nast¹pi jakakolwiek inicjalizacja!.
Jeœli inicjalizacja nie nast¹pi w miejscu definicji, to nadal nie mamy gwarancji, ¿e dokona siê przed przes³aniem komunikatu do referencji 
reprezentuj¹cej obiekt - nieuchronnie objawi siê to wyj¹tkiem w czasie dzia³ania programu. 
Metoda toString wype³nia obiekt wskazywany przez s4, wiêc wszystkie pola s¹ prawid³owo zainicjowane przed wykorzystaniem.

2. Sk³adnia dziedziczenia

	Dziedziczenie jest u¿ywane zawsze kiedy tworzymy jak¹œ klasê, gdy¿ je¿eli nawet nie dziedizczymy bezpoœrednio z innej klasy, to automatycznie
dziediczymy ze standardowej g³ownej klasy bazowej Object.
	Sk³adnia kompozycji jest oczywista, ale by zastosowaæ dziedziczenie, trzeba u¿yæ ca³kowicie innego zapisu. Dziedzicz¹c, mówimy, ¿e ta nowa klasa
bêdzie podobna do tamtej klasy. Tutaj w kodzie dodajemy s³owko kluczowe extends. Kiedy to zrobimy automatycznie zyskamy wszystkie zmienne i metody
sk³adowe klasy bazowej. Przyk³ad w klasach Cleanser i Detergent.

	Przyk³ad pokazuje du¿o ciekawych mo¿liwoœci. +=, co jest przeci¹¿onym operatorem przez Jave do pracê z ³añcuchami tekstowymi. Po drugie Clenanser
jak i Detergnet zawieraj¹c main(). Mo¿na stworzyæ wiêc main dla ka¿dej z klas, co pozwala na ³atwe testowanie. No i nie ma koniecznoœci usuwania tej metody
po zakoñczeniu testów, mo¿na j¹ pozostawiæ do pózniejszego sprawdzenia. Bo w przypadku wielu klas w proramie, metoda main zostanie uruchomiona
tylko z tej klasy która zosta³a wywo³ana w wierszu poleceñ, tzn zosta³a odpalona.

Co istotne - wszystkie metody klasy Cleanser sa publiczne. Pamietajmy, ze jak nie okreslimy zadnego specyfikatora dostêpu dla sk³adowej, to domyœlnie
bêdzie mia³a ona "przyjazdny", co pozwoli na dostêp jedynie sk³adowym pakietu. KCo zonacza, ze wewnatrz tego pakietu, bez podania specyfikatora
dostêpu kla¿dy móg³by u¿ywaæ tych metod - klasa Detergent nie mia³aby wiêæ z tym prblemów. Jednak gdyby jakaœ klasa z innego pakietu dziedziczy³a
po Cleanser, to mog³aby jedynie siêgn¹æ do jej sk³adowych publicznych. Aby jednak umo¿liwiæ dziedziczenie, stosuj zasadê okreœlania wszystkich pól
jako private, a metod jako public (na dostêp z klas pochodnych zezwaj¹ równie¿ protected). 

Stostuj¹c dziedziczenie nie jesteœmy ograniczeni jedynie do wykorzystywania metod klasy bazowej. Mo¿na równie¿ dodawaæ nowe metody do klasy pochodnej,
dok³adnie w taki sam sposób, jak dodaje siê dowoln¹ metodê.

	a. Inicjalizacja klasy bazowej
	
	Mamy wiêc teraz dwie klasy powi¹zanme ze sob¹ - bazow¹ i jej pochjodn¹, wiêc ciê¿kie mo¿e byæ wyobra¿enie sobie obiektu wynikowego z klasy pochodnej.
Na zwewn¹trz wygl¹da to tak, jakby nowa klasa posiada³a ten sam interfejs co klasa bazowa i kilka dodatkowych pól/metod. Lecz dziedziczenie to nie tylko
skopiowanie klasy bazowej. Kiedy tworzymy obiekt klasy pochodnej to zawiera on w sobie klasê bazow¹ jako PODOBIEKT, czyli taki jakby osobno utworzony
obiekt klasy bazowej. Jest on opakowany przez obiekt klasy pochodnej.
	Wa¿ne, by podobiekt klasy bazowej zosta³ zainicjowany poprawnie i oczywiœcie jest tylko jeden sposób, ¿eby to zapewniæ: wykonaæ inicjalizacjê w
konstrzuktorze poprzez wywo³anie konstruktora klasy bazowej, który dysponuje ca³¹ wiedz¹ i uprawnieniami by dokonaæ takiej inicjalizacji. Wywo³ania
konstruktora klasy bazowej w Javie do³¹czane s¹ AUTOMATYCZNIE w konstruktorach klasy pochodnej. Widaæ to w dzia³aniu na przyk³adzie dziedziczenia
trójpoziomego w klasach Art, Drawing i Cartoon.
	Widaæ tam, ¿e konstruowanie przebiega od góry, wiêc klasa bazowa jest inicjowana, zanim konstruktor klasy pochodnej mo¿e uzyskaæ do niej dostêp.
Nawet gdy nienapisalibyœmy  konstruktora dla klasy Cartoon, to kompilator jak ju¿ wiemy do³¹czy za nas i tak konstruktor domyœlny, który wywo³ywa³
bêdzie konstruktor klasy bazowej.

	b. Konstruktory z argumentami
	
	W przyk³adzie wy¿ej mamy konstruktory domyœlne. Tzn niepobieraj¹ce ¿adnych parametrów. Ich wywo³ywanie jest wiêc proste, nie powstaje pytanie jakie
parametry przekazaæ. Jeœli klasa nie zawiera parametrów domyœlnych lub kiedy chemy wyo³aæ sparametryzowany konstruktor klasy bazowej, trzeba zastosowaæ
s³owo kluczowe SUPER i podaæ odpowiednie argumenty. Przyk³ad w klasach Game, BoardGame i Chess
	Je¿eli nie wywo³amy konstruktora klasy bazowej w BoardGame, to kompilator bêdzie informowa³, ¿e nie mo¿e odnalezæ konstruktora Game(). Na dodatek
wywo³anie konstruktora klasy bazowej musi byæ pierwsz¹ instrukcj¹ w konstruktorze klasy pochodnej (jakby co kompilator o to sie upomni ;) )
	
	
3. DELEGACJE

	Trzeci rodzaj relacji, który nie jest wprost obs³ugiwany przez Jave (C# chyba jest). Jest to relacja poœrednia pomiêdzy dziediczeniem a kompozycj¹,
bo zak³ada osadzanie w budowanej klasie obiektu innej klasy, ale z równoczesn¹ ekspozycj¹ wszystkich metod tego obiektu w nowej klasie (jak w 
dziedziczeniu). Przyk³ad w klasach SpaceShipControls i SpaceShip i SpaceShipDelegation.
	W³aœciwy statek kosmiczny mo¿emy zmontowaæ oczywiœcie za pomoc¹ dziedziczenia (SpaceShip). Ale SpaceShip nie pozostaje w relacji "jest typu" z klas¹ SpaceShipControls,
mimo, ¿e mo¿na nakazaæ obiektowi SpaceShip wykonanie np. forward(). Mode³ by³by dok³adniejszy, gdybyœmy powiedzieli, ¿e SpaceShip zaweira w sobie
SpaceShipControls, a wszystkie metody SpaceShipControls s¹ EKSPONOWANE w klasie SpacheSHip. Delegacja s³u¿y w³asnie do tego (klasa SpaceShipDelegation).
	W przyk³adzie delegacji (SpaceShipDelegation) widaæ, ¿e wywo³ania s¹ przekazywane do zawieranego obiektu controls. Interfejs obiektu zaweiraj¹cego jest 
identyczny jak w przypadku dziedziczenia, ale delegacja daje wiêksz¹ kontrolê, bo pozwala choæby na wybiórcze udostêpnianie fragmentów interfejsu obiektu
zawieranego

4. £¹czenie kompozycji i dziediczenia

Stosowanie ich razem jest normalne. Przyk³¹d str 220

5. Zapewnienie poprawnego sprz¹tania

W javie nie mamy destruktorów - nie musimy pamiêtaæ o niszczeniu obiektu i je zostawiamy, pozwalaj¹c w zamian odœmiecaczowi pamiêci na odzyskanie
pamiêc iw razie potrzeby. Zazwyczaj jest to dorbe rozwi¹zanie, ale zdarzyæ siê mo¿e, ¿e klasawykonujepewne dzia³ania podczas swojego zycia, tkore 
na koniec wymagaj¹ wykonania porz¹dków. Jak ju¿ omawia³em podczas Inicjalizacji i sprz¹tania", nie wiadomo kiedy zostanie uruchomiony odœmiecacz,
a nawet czy w ogóle zosatnie uruchomiony. Dlatego te¿ je¿eli musimy po czymœ sprz¹tn¹c, trzeba dopisaæ specjaln¹ metodê, która to zrobic i ipewniæ siê,
¿e u¿ywaj¹cy klasy wiedz¹, ¿e musz¹ j¹ wywo³aæ. Trzeba te¿, o czym bêdzie mowa w obs³udze wyj¹tków, chroniæ siê przed wyj¹tkami poprzez zamieszczanie
takiego sprz¹tania w klazuli finally.

	Na przykladzie klas Shaoe, Circle, Traiangle, Line i CadSystem. Wszystko w przykladzie jest figura (obiekt rodzaju Shape(), który z kolei jest typu
Object). Ka¿da z klas przedefiniowuje metodê dispose() klasy Shape wywo³uj¹c te¿ wersjê tej metody z klasy bazowej. Wszystkie wyspecjalizowane klasy
typu Shape posiadaj¹ konstruktor, choæ dowolna metoda wywo³ana w czasie ¿ycia obiektu mo¿e wykonywaæ coœ, co wymaga sprz¹tniêcia. Ka¿da z klas
posiada w³asn¹ metodê dispose() pozwalaj¹c¹ przywróciæ rzeczy nie zwi¹zane z pamiêci¹ dostanu przed powstaniem obiektu.
	W metodzie main() pojawi³y siê nam dwa nowe s³owa kluczowe: TRY I FINALLY, z obs³ugi blêdów za pomoc¹ wyj¹tków. Try sugnalizuje, ¿e rozpoczynaj¹ct
siê blok jest obszarem chronionym, czli jest specjalnei traktowany. Jednym z takihc elementów specjalnego traktowania jest to, ¿e kod zamieszczony w 
klauzuli finally bêdzie wykonywany zawsze, bez wzdlêdu na to, jak zakoñczy siê sam blok try. W przyk³¹dzie finally zawsze wywo³a metodê dispose.
	W metodzie sprz¹taj¹cej (dispose) trzeba te¿ zwróciæ uwagê na kolejnoœæ wywo³ywania metod sprz¹taj¹cych dla klasy bazowej i obiektów sk³adowych
na wypadek, gdyby jeden podobkiet zale¿a³ od innego!! Powinno siê generalnei stosowaæ tak¹ sam¹ regu³e, jaka jest narzucona dla destruktórw z C++:
najpierw wykonaæ sprz¹tanie specyficzne dla danej klasy, w kolejnoœci odwrotnej od tworzenia, a nastepnie, jak to zosta³o tutaj zaprezentowane,
wywo³aæ metodê sprz¹taj¹c¹ klasy bazowej.
	Istnieje du¿o systuacji, w których kwestia odzyskania pamiêci nie bêdzie ¿adnym problemem, p prostu pozwalamy odœmiecaczowi pamiêci pracowaæ. 
Jednak gdy trzeba zrobiæ to bezpoœrednio, konieczne jest zachowanie szczególnej ostro¿noœci! Bo niewielu rzeczy mo¿na byæ pewnym je¿eli chodzi
o odœmiecacz pamiêcu. Odsmiecanie mo¿e w ogole nie zostaæ wywo³ane. Mo¿e te¿ odzyskiwaæ obiektu w takim porz¹dku, jaki sobie wybierze.
Najlepiej polegaæ na odsmiecaczu tylko w przypadku zwrotu pamiêci. Je¿eli chcemy, by mia³o miejsce jakieœ sprz¹tanie, najlepiej wypisaæ w³asne metdody
i nie polegaæ na metodzie finalize().


6. Ukrywanie nazw
	Jeœli klasa bazowa zaweira metodê, której nazwa jest przeci¹¿ona kilka razy, to definicja metody o takiej samej nazwie w klasie pochodnej nie
spowoduje zakrycia ¿adnej z wersji zamieszczonych w klasie bazowej (nie tak jak w c++). Tym sposobem przeci¹¿anie dzia³¹ niezale¿nie od tego, czy
dana metoda zdefiniowana by³a na tym poziomie czy te¿ w klasie bazowej. Widaæ to na przyk³adzie klas Homer i Bart i Milhouse i Hide.
	Przyk³ad ten pokazuje, ¿e wszystkie przeci¹¿one metody klasy Homer dostêpne s¹ w klasie Bart pomimo tego, ¿e w klasie tej zosta³a zdefiniowana
nowa metoda przeci¹¿ona. Jednak znacznie czêœciej stosowane jest przes³anianie metod o tej samej nazwie z tak¹ sam¹ sygnatur¹ i typem
zwracanym jak w klasie bazowej. W innym przypadku definicja metody o tej samej nazwie w klasie pochodnej mo¿e byæ mul¹ca. W zwi¹zku z tym w Javie SE5
dodano adnotacje @Override, która jest wykorzystywana jak s³owa kluczowe ale nie jest s³owiem kluczowym. Kiedy chcemy wiêc przes³oniæ metodê, mo¿emy
zastosowaæ tak¹ adnotacjê. Kompilatot wtedy wykryje ¿e zamiast przes³aniania mamy przeci¹¿anie i wystosuje komunikat o b³êdzie (bo mieliœmy char doch()
a zmieniliœmy na void doh i dodaliœmy override). Pojawi siê {CompileTimeError} który wy³¹cza powy¿szy kod z automatycznej, zbiorowej kompilacji przyk³adów/
Zapis override chorni wiêc przed przypadkowym przeci¹¿eniem tam, gdzie chodzi nam o przes³oniêcie.


7. SLOWA KLUCZOWE FINAL

	W zale¿noœci od kontekstu mo¿e mieæ ró¿ne znaczenie, ale generalnie oznacza, ¿e zmienna nie mo¿e byæ zmieniona. S¹ trzy sytuacje, wk tórych mo¿emy stosowaæ
final: dla klas, metod i zmiennych.

	A. ZMIENNE FINALNE
	Praktycznie w wiêkszoœci jêzyków istnieje mo¿liwoœæ zdefiniowania zmiennej jako STA£EJ (CONST). Dlaczego s¹ one przydatne? No bo mog¹ istnieæ sta³e czasu
kompilacji, które nigdy nie bêd¹ zmieniane oraz te¿ mog¹ to byæ wartoœci inicjowane w czasie dzia³ania, których nie chcemy modyfikowaæ.
	W przypadku sta³yuch czasu kompilacji kompilator ma mo¿liwoœæ umieszczenia wartoœci sta³ej wewn¹trz obliczeñ, w których jest ona u¿yta, co oznacza, ¿e obliczcenia
mog¹ siê wykonaæ w czasie kompilacji, co eliminuje koszty podczas wykonania. W Javie sta³e tego typy musz¹ byæ reprezentowane przez zmienne typu podstawowego no i za
pomoc¹ s³ówka kluczowego final. Wartoœc musi zostaæ przypisana W MIEJSCU DEFINICJI STA£EJ.

	Pole, które jest i statyczne i finalne jednoczeœnie, zajmuje tylko jeden okreœlony fragment pamiêci i do tego jeszcze nie mo¿e ulec zmianie.

	Gdy stosujemy final dla referencji do obiektów, znaczenie mo¿e byæ troszkê myl¹ce, bo dla typu elementarnego to wartoœæ staje siê sta³¹, a dla referencji do obiektu to
referencja staje siê sta³¹. Gdy zainicjujemy j¹ jako odwo³anie do konkretnego obiektu, to nigdy nie bêdzie mo¿na jej zmieniæ tak, by wskazywa³a na inny obiekt. ALE!
SAM obiekt mo¿e byæ modyfikowany (w Javie nie ma sposobu, by uczyæ jakiœ obiekt niezmiennym, no chyba ¿e napiszemy jak¹œ klasê z samymi pirvateami). Co wiêcej, takie
same ograniczenie dotyczy tak¿e tablic (które te¿ s¹ OBIEKTAMI!).

	W klasie FinalData i Value zaprezentowany przyk³ad z polami finalnymi. Zwróciæ uwagê na nazy pól.
	Poniewa¿ valueOne i VALUE_TWO, które s¹ typu podstawowego, s¹ zadeklarowane jako finalne, to mog¹ byæ u¿yte jako sta³e ju¿ podczas kompilacji i tak w³aœnie jest.
VALUE_THREE jest bardziej typowym sposobem definiowania takich sta³ych, tzn jest publiczna, statyczna (by zaznaczyc ze jest tylko jedna) no i finalna. Zmienne z modyfikatorami
final static zainicjowane jako wartoœci sta³e (oznacza to, ¿e s¹ sta³ymi czasu kompilacji) s¹ z zasady nazywane du¿ymi literami.
	Z faktu, ¿e coœ jest finalne, nie wynika, ¿e jego wartoœæ jest znana podczas kompilacji. Widaæ to na przyk³adzie inicjalizacji zmiennych i4 i INT_5, które inicjowane s¹ w
czasie wykonania z zastosowanie liczb losowych. Ten fragment kodu pokazuje te¿ ró¿nice miêdzy uczynieniem finaln¹ zmiennej statycznej a egzemplarzowej. Ró¿nica ujawnia siê wtedy jedynie,
gdy wartoœci s¹ inicjowane w czasei dzia³ania, bo wartoœci czasu kompilacji s¹ traktowane przez kompilator tak samo. Wartoœæ zmiennej i4 jest unikatowa dla obiektów fd1 i fd2,
natomiast wartoœæ INT_5 nie ulega zmianie po utworzeniu drugiego obiektu klasy FinalData!!!!! Dlatego, ¿e jest to zmienna statyczna i jest inicjowana wy³¹cznie RAZ PODCZAS £ADOWANIA, a nie
za ka¿dym razem, kiedy tworzony jest obiekt.
	Zmienne v1 do VAL_3 s¹ przyk³¹dem znaczenia referencji z modyfikatorem final. Jak zauwa¿amy w metodzie main(), z tego, ¿e v2 jest finalna, wcale nie wynika ¿e nie mo¿na zmieniæ wartoœci
tego obiektu. Nie mo¿na tylko przepi¹æ v2 do nowego obiektu, bo jest finalna. v2 zawiera referencje, a wiêc final oznacza, ¿e nie mo¿na jej przestawiæ. Takie samo dzia³anie jest w przypadku
tablic, które s¹ trochê innym rodzajem referencji (nie ma sposobu na uczynienie referencji w tablicach same w sobie finalnymi). Stworzenie wiêc referencji finalnej jest trochê
mniej przydatne ni¿ stworzenie finalnych zmiennych podstawowych.

	A1. PUSTE ZMIENNE FINALNE
	Mo¿emy te¿ tworzyæ puste zmienne finalne bêd¹ce polami zadeklarowanymi z modyfikatorem final, ale jeszcze nie zainicjalizowanymi. Zmienne takie jednak musz¹ zostaæ zainicjowane przed u¿yciem, 
o co zreszt¹ te¿ zadba i dopilnuje kompilator. Puste zmienne finalne zapewniaj¹ wiêc wiêksz¹ elastcznoœæ - np finalne pola sk³adowe mog¹ teraz byæ ró¿ne dla ka¿dego z obiektów i w dodatku
zachowuj¹ w³aœciwoœæ niezmiennoœci. Przyklad w klasie Poppet i BlankFinal. Kompilator wymusza przypisanie wartoœci zmiennym finalnym klasy albo w miejscu definicji, albo w ka¿dym z konstruktorów.
Dziêki temu mamy pewnoœc, ¿e pola final zawsze s¹ zainicjalizowane.

	A2. FINALNE ARGUMENTY
	Mo¿emy te¿ uczyniæ finalnymi argumenty metody. To oznacza, ¿e wewn¹trz metody nie mo¿na zmieniæ ich wartoœci. Np nie mozna w void f(final int i) zinkrementowac i: {i++ }. Z referencjami
wiadomo, nie mo¿na przepi¹c referencji. Tutaj chyba niepotrzebny przyk³ad, a jak coœ to zó³æ. W przypadku metod ze zmiennymi finalymi mo¿na jedynie odczytaæ wartoœæ, lecz nie mo¿na jej zmieniæ.
Takie coœ wykorzystuje siê przede wsyzstkim do przekazywania danych do nienazwanych klas wewnêtrznych, o którym se powiemy kiedyœ.

	B. METODY FINALNE
	S¹ 2 powody by metody zaznaczaæ jako finalne: jest to jakby za³o¿enie blkady na metodê, ¿eby klasy pochodne nie mog³y dokonywaæ ¿adnych zmian. Drugi powód zwi¹zany jest z kwesti¹ wydajnoœci. Jeœli
metoda zostanie finalna, pozwoli to kompilatorowi zamieniæ wywo³ania metody na wywo³ania w miejscu (tzw. inline). Kiedy kompilator napotka wywo³anie metody finalnej, mo¿e dyskretnie omin¹æ normaln¹
procedurê w³¹czenia kodu s³u¿¹cego do wywo³ania metody (po³o¿enie argumentów na stosie, skok do kodu metody i jego wykonanie, powrót, wyczyszczenie stosu z do³o¿onych argumentów i przekazanie
wartoœci zwracanej), zastêpuj¹c takie wywo³anie metody skopiowaniem jej rzeczywistego kodu. Dziêki temu narzut kosztów wywo³ania metody zostaje wyeleminiwany. Oczywiœcie jeœli metoda jest du¿a, kod staje
siê rozbudowany i raczej nie ma to ¿adnych korzyœci, bo jakakolwek poprawa bêdize bardoz ma³a w stosunku do czasu spêdzonego w metodzie. Obecnie w javie od chyba 5+ okreœlanie metod finalnymi jest zbêdne,
bo maszyna  wirtualna potrafi sama wykryœ takie sytuacje i w toku optymalizacji pozbyæ siê poœrednioœci. Tak wiêc w javie 5+ kwestie wydajnoœci nale¿y zostawiaæ kompilatorowi i maszynie wirtualnej,
a metody oznaczaæ final tylko wtedy, kiedy chcemy zapobiec ich przes³oniêciu.

	B1. final i private
	Ka¿da metoda prywatna klasy w pewien sposób staje siê te¿ finalna, bo nie ma do niej dostêpu z zewn¹trz, wiêc te¿ nie mo¿na ich przes³oniæ. final w takim przypadku obok private niczego nie daje.
Kwestia ta mo¿e wprwoadzaæ w b³¹d, bo jak chcemy przes³oniæ metodê prywatn¹, wydaje siê ¿e to dzia³a (bo kompilator nie zg³osi ¿adnych b³êdów), ale tak naprawdê my nie przes³aniamy, tylko tworzymy wtedy
now¹ metodê. Bo przes³oniêcie mo¿e mieæ miejsce tylko wtedy, gdy coœ jest czêœcia interfejsu klasy bazowej. Czyli musimy mieæ mo¿liwoœæ rzutowania obiektu na klasê bazow¹ i wywo³ania tej samej metody
(wyjaœnie to bardizej póniej). Je¿eli metoda jest prywatna, to nie zalicza siê jej do interfejsu klasy bazowej. Jest to po prostu jakiœ ukryty kod wewn¹trz klasy.


	C. KLASY FINALNE
	Kiedy okreœlimy jak¹s ca³¹ klasê jako finaln¹, to dajemy znaæ, ¿e nie pozwalamy z niej dziedziczyæ. Czyli jest to za³o¿enie, ¿e nigdy nie bêdzie potrzeby dokonywania ¿adnych zmian lub te¿ ze wzglêdów
bezpieczeñstwa nie chcemy dalej dziedziczyæ. 
	Pola klasy mog¹ byæ finalne niezale¿nie od naszego wyboru. Ta sama zasada dotyczy stosowania final wobec sk³adowych klasy, bez wzglêu na to czy klasa jest finalna. Final przed klas¹ jedyne co robi to
zabrania z niej dziedziczenia. NO I! Z uwagi na to, ¿e nie mo¿na dziedziczyæ to wszystkie metody klasy finalnej staj¹ siê równie¿ finalne, no bo przecie¿ nie ma mo¿liwoœci ich przes³oniêcia. Mo¿emy dopisaæ
te modyfikatory, ale to nieczego nie zmienia.

	TAK NA MARGINESIE - OSTROZNIE Z DEKLARACJA FINAL
	Stosowanie metod finalnych wydaje sie praktyczne. Mozemy myslec, ¿e wydajoœæ jest bardzo istotna podczas u¿ywania klasy i prawdopodobnie nikt nie bêdzie przes³ania³ naszych metod. Czasami jest to prawd¹.
Przy takich za³o¿enia trzeba byæ ostro¿nym, bo trudno jest przewidzieæ, jak klasa mo¿e byæ wykorzystywana, szczególnie taka ogólnego przeznaczenia. Jeœli okreœlimy metode finaln¹, to zablokujemy mo¿liwoœæ
powtórnego wykorzystania klasy przez dziedziczenie w kilku innych projektach z powodu braku wyobrani, ¿e mo¿e byæ tak wykorzystana.


	D. INICJALIZACJA I LADOWANIE KLAS
	W wiêkszoœci jêzyków programy ³adowane s¹ w ca³oœci podczas startu, pózniej nastêpuje inicjalizacja i wtedy program rozpoczyna dzia³anie. Prces inicjalizacji musi wtdy byæ starannie kontrolowany, by
przypadkiem kolejnoœæ inicjalizacji zmiennych statycznych nie sprawia³a k³opotów. Np C++ ma problemy, jesli jedna mzienna statyczna dla swojjej porapwanej konstrukcji wymaga pobrania wartoœc iinnej, zanim
ona zostanie zainicjalizowana.
	W Javie na szczêœci nie ma takiego problemu, bo mechanizm ³adowania klas jest tu trochê inny. To jedna z czynnoœci upraszczanych podejœciem polegaj¹cym na reprezentowaniu wszystkiego obiektami.
Skompilowany kod ka¿dej klasy jest przechowywany w oddzielnym pliku. Plik taki nie jest wczytywany, dopóki kod nie jest potrzebny. Mo¿na powiedzieæ, ¿e kod klasy jest ³adowany podczas pierwszego u¿ycia.
Jest to zwykle moent utworzenia pierwszego obiektu danej klasy, ale tak naprawdê wczytanie klasy mo¿e nast¹piæ wczeœniej, np w wyniku wywo³ania statycznej metody albo odwo³ania do statycznego pola tej klasy.
(Co warto zauwazycm konstruktor klasy rowniez jest metoda statyczna! Mimo braku slowa static. Ladowanie klasy nastêpuje wiêc w momencie pierwszego odwo³ania do jakiejkolwiek statyucznej sk³adowej klasy).
	Czas pierwszego wykorzystania to te¿ miejsce inicjalizacji zmiennych statycznych. Wszystkie obiekty statyczne i bloki statyczne s¹ podczas ³adowania inicjalizowane w porz¹dku tekstowym (czyli w kolejnoœci,
w jakiej zosta³y wpisane w definicji klasy). No i jak wiadomo, to co statyczne inicjalizowane jest tylko raz.

	D1. INICJALIZACJA W PRZYPADKU DZIEDZICZENIA
	Zobaczmy przyklad procesu inicjalizacji z w³¹czeniem mechanizmu dziedziczenia. Na przykladzie klas Insect i Beetle. Najpierw interpreter Javy odnajdzie metodê Beetle.main() (jest statyczna), dalej modu³
³aduj¹cy bêdzie szuka³ skompilowanego kodu klasy Beetle (w pliku Beetle.class). Podczas ³adowania kodu klasy modu³ ³aduj¹cy ddostrzeze, ¿e ma ona klasê bazow¹ (extends), która nastêpnie wczytuje, niezale¿nie
od tego, czy tworzymy obiekt klasy bazowej czy nie.
	Je¿eli klasa bazowa ma z kolei swoj¹ klasê bazow¹, to wtedy ta druga bêdzie te¿ ³adowana itp. Nastêpnie wykonywana jest inicjalizacja zmiennych statycznych g³ównej klasy bazowej i dalej to samo w klasie
pochodnej itp. Jest to wa¿ne, bo inicjalizacja statyczna w klasach pochodnych mo¿e zale¿eæ do w³aœciwej inicjalizacji sk³adowych klasy bazowej.
	Teraz, gdy wszystkie wymagane klasy s¹ ju¿ za³adowane, mo¿e nast¹piæ tworzenie obiektu. Najpeirw wszystkei typy podstawowe w obiekcie ustawiane s¹ na odpowiednie wartoœci domyœlne, a referencje obiektów
na null (wszystko jednym, p³ynnym ruchem, przez binarne wyzerowanie pamiêci obiektu). Wtedy wywo³ywane jest konstruktor klasy bazowej. W przyk³¹dzie wywo³ane jest automatyczne, ale mo¿na równie¿ okreœliæ
takie wywo³anie konstruktora klasy bazowej (jako pierwsz¹ operacjê w konstruktorze klasy Beetle(), stosuj¹c s³ówka SUPER. Konstruktor klasty bazowej podlega temu samemu procesowi w tym samym porz¹dku, co 
konstruktor klasy pochodnej. Po zakoñczeniu dzia³ania konstruktora klasy bazowej inicjalizwane s¹ zmienne egzemplarza, w kolejnoœci wyst¹pienia. Na koniec dopiero wykonywana jest reszta kodu konstruktora.

	PODSUMOWANIE
	Kompozycja i dziedziczenia pozwalaj¹ na stworzenie nowych typoów danych z typów ju¿ istniej¹cych. Kompozycjê stosuje siê w celu ponowengo wykorzystania istniej¹cych typów jako czêœci wewnetrznej implemetacji,
a dziedziczenie, kiedy chcemy ponownie wykorzystaæ interfejs.
	Przy dziedziczeniu klasa pochodna ma te¿ interfejs swojego przodka, mo¿e byæ wiêæ rzutowana w górê do klasy bazowej (ma to znaczenie dla polimorfizmu).
	Mimo nacisku na nauke dziediczenia, w programowaniu obiektowym na pocz¹tku powinno preferowaæ siê kompozycjê, a dziedziczenie stosowac tylkowtedy, gdy naprawde jest konieczne. Kompozycja bywabardziej
elastyczna. Dodatkowo stosujac w³aœciwoœc idziedziczenia, mo¿na zmienic w³aœciwy typ obiektów sk³adowych i tym sposobem zachowanie tych obiektów podczas pracy programu. Mo¿na wiêc zmieniæ w trakcie dzia³ania programu
zachowanie obiektu bêd¹cego kompozycj¹ innych obiektów.

	
